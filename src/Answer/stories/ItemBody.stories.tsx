import React from 'react';
import { action } from '@storybook/addon-actions';
import { storiesOf } from '@storybook/react';
import { ItemBody } from '../ItemBody';

const bodyText = "<p>Consider  the following example</p>\n\n<pre><code>type A = { [prop: string]: any };\ntype B = { [prop: string]: any; prop1: string };\n</code></pre>\n\n<p>Does type <code>B</code> extend type <code>A</code>? Yes!</p>\n\n<p>But the following will not work</p>\n\n<pre><code>let a: A = {};\nlet b: B = a; // Error\n</code></pre>\n\n<p>It's clear that type <code>A</code> misses required property <code>prop1</code>, so variable <code>a</code> is not assignable to variable <code>b</code>.</p>\n\n<p>The same issue is with your function. When you do</p>\n\n<pre><code>function f1&lt;T extends { [prop: string]: any }&gt;(a: T = {}) {\n    console.log(a);\n}\n</code></pre>\n\n<p>Compiler says that object <code>{}</code> is not assignable to type <code>T</code>. If this worked, you could do</p>\n\n<pre><code>f1&lt;B&gt;();  // a will equal to {} and misses required prop1\n</code></pre>\n\n<p>This may not look like error, as inside <code>f1</code> you only know that <code>T extends { [prop: string]: any }</code> and know nothing about <code>prop1</code>. But consider if you want return <code>T</code>:</p>\n\n<pre><code>function f1&lt;T extends { [prop: string]: any }&gt;(a: T = {}): T {\n    console.log(a);\n    return a;\n}\n</code></pre>\n\n<p>If this code would work it would introduce a bug</p>\n\n<pre><code>let bb: B = f1&lt;B&gt;();  // Here bb will be equal to empty object\nlet s: string = bb.prop1;  // Compiler will not show error, as it thinks that bb has prop1 of type string. But in reality it is undefined.\n</code></pre>\n\n<p>So there are following solutions to consider:</p>\n\n<ol>\n<li><p>Remove all generics. Type <code>{ [prop: string]: any }</code> is generic by itself so it may suit your needs</p>\n\n<pre><code>function f1(a: { [prop: string]: any } = {}) {\n    console.log(a);\n    return a;\n}\n</code></pre></li>\n<li><p>Make <code>a</code> fully optional. In this case <code>a</code> may equal to <code>undefined</code> and compiler would know about it. </p>\n\n<pre><code>function f1&lt;T extends { [prop: string]: any } = {}&gt;(a?: T) {\n    console.log(a);\n}\n</code></pre>\n\n<p>If you return <code>a</code> compiler will tell you that you should either return union type (with <code>undefined</code>) or check in function body that <code>a</code> is not <code>undefined</code>.</p></li>\n<li><p>Worst case from my point of view is to use type cast as already suggested</p>\n\n<pre><code>function f1&lt;T extends { [prop: string]: any }&gt;(a: T = {} as T) {\n    console.log(a);\n}\n</code></pre>\n\n<p>But be careful and don't forget that you can miss some required properties in this case.</p></li>\n</ol>\n";
//const bodyText = "<pre><code>function f1&lt;T extends {[prop: string]: any}}&gt;(a: T = {}) {\n    console.log(a)\n}\n</code></pre>\n\n<blockquote>\n  <p>Error: Type '{}' is not assignable to type 'T'.</p>\n</blockquote>\n\n<p>im trying to give a a default value. im not trying to give T a default type. </p>\n\n<p>I'm not sure what is the problem.</p>\n";

storiesOf('ItemBody', module)
  .add('default', () => <ItemBody bodyText={bodyText}/>)